<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://easrai.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://easrai.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-07T18:41:48+00:00</updated><id>https://easrai.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">numpy arrays</title><link href="https://easrai.github.io/blog/2025/The-NumPy-ndarray-A-multidimensional-array/" rel="alternate" type="text/html" title="numpy arrays"/><published>2025-05-26T14:24:00+00:00</published><updated>2025-05-26T14:24:00+00:00</updated><id>https://easrai.github.io/blog/2025/The-NumPy-ndarray-A-multidimensional-array</id><content type="html" xml:base="https://easrai.github.io/blog/2025/The-NumPy-ndarray-A-multidimensional-array/"><![CDATA[<p>NumPy, short for Numerical Python, is one of the most important foundational packages for numerical computing in Python. Most computational packages providing scientific functionality use NumPy’s array objects as the <em>lingua franca</em> for data exchange</p> <p>Some of the things in NumPy:</p> <ul> <li>ndarray, an efficient multidimensional array providing fast array-oriented arithmetic operations and flexible broadcasting capabilities.</li> <li>Mathematical functions for fast operations on entire arrays of data without having to write loops.</li> <li>Tools for reading/writing array data to disk and working with memory mapped files.</li> <li>Linear algebra, random number generation, and Fourier transform capabilities.</li> <li>A C API for connecting NumPy with libraries written in C, C++ or FORTRAN. <h2 id="the-numpy-ndarray-a-multidimensional-array-object">The NumPy ndarray: A Multidimensional Array Object</h2> </li> </ul> <p>N-dimensional array object or ndarray is a fast, flexible container for large datsets in Python. They enable us to perform mathematical operations on whole blocks of data using similar syntax to the equivalent</p> <pre><code class="language-Python">In[12]: import numpy as np
#Generate some random data
In[13]:data = np.random.module.randn(2,3)

In[14]:data
Out[14]:
array([[-0.2047, 0.4789, -0.5194],
		[-0.5557, 1.9658, 1.3934]])
</code></pre> <p>Then i can do mathematical operations with data like <code class="language-plaintext highlighter-rouge">data + data</code> and <code class="language-plaintext highlighter-rouge">data * 10</code> etc. An ndarray is a generic multidimensional container for homogenous data that, all of the elements must be of the <strong>same type</strong>.</p> <p>Every array has a <em>shape</em> indicating size of each dimension and <em>dtype</em>, an object describing <em>data type</em> of the array:</p> <pre><code class="language-Python">In [17]:data.shape
Out[17]: (2,3)

In [18]:data.dtype
Out[18]:dtype('float64')
</code></pre> <p>This chapter will introduce you to the basics of using NumPy arrays adn should be sufficient for following along with the rest of the book</p> <h2 id="creating-ndarrays">Creating ndarrays</h2> <p>The easiest way to create an array is using the <code class="language-plaintext highlighter-rouge">array</code> function. This accepts any sequence-like object (including other arrays) and produces a new NumPy array containing the passed data. For example, a list is a good candidate for conversion:</p> <pre><code class="language-Python">In [19]: data1 = [6, 7.5, 8, 0, 1]

In [20]: arr1 = np.array(data1)

In [21]: arr1
Out[21]:array([ 6. , 7.5, 8. , 1. ])
</code></pre> <p>Nested sequences like a list of equal length lists, will be converted into a multidimensional array:</p> <pre><code class="language-Python">In [22]: data2 = [[1, 2, 3, 4],[5, 6, 7, 8]]

In [23]: arr2 = np.array(data2)

In [24]: arr2
Out[24]:
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
</code></pre> <p><code class="language-plaintext highlighter-rouge">.ndim</code> method returns the length of array.</p> <p>Unless explicitly specified <code class="language-plaintext highlighter-rouge">np.array</code> tries to infer a good data type for the array that it creates. The data type is stored in a special <code class="language-plaintext highlighter-rouge">dtype</code> metadata object; for example, in the previous two examples we have:</p> <pre><code class="language-Python">In [27]: arr1.dtype
Out[27]: dtype('float64')

In [28]: arr2.dtype
Out[28]: dtype('int64')
</code></pre> <p>In addition to <code class="language-plaintext highlighter-rouge">np.array</code>, there are a number of other functions for creating new arrays. As examples, <code class="language-plaintext highlighter-rouge">zeros</code> and <code class="language-plaintext highlighter-rouge">ones</code> create arrays of 0s and 1s respectively with a given length or shape <code class="language-plaintext highlighter-rouge">empty</code> creates an array without initializing its values to any particular value. To create a higher dimensional array with these methods pass a tuple for the shape</p> <h2 id="data-types-for-ndarrays">Data Types for ndarrays</h2> <p>The <em>data type</em> or <code class="language-plaintext highlighter-rouge">dtype</code> is a special object containing the information (or <em>metadata</em>, data about data) the ndarray needs to interpret a chunk of memory as a particular type of data:</p> <pre><code class="language-Python">In [33]: arr1 = np.array([1, 2, 3], dtype=np.float64)

In [34]: arr2 = np.array([1,2,3], dtype=np.int32)

In [35]: arr1.dtype
Out[35]: dtype('float64')
In [36]: arr2.dtype
Out[36]: dtype('int32')
</code></pre> <p>dtypes are a source of NumPy’s flexibility for interacting with data coming from other systems.</p> <p>You can explaicitly convert or <em>cast</em> an array from one dtype to another using ndarray’s <code class="language-plaintext highlighter-rouge">astype</code> method:</p> <pre><code class="language-Python">In [37]: arr = np.array([1, 2, 3, 4, 5])

In [38]: arr.dtype
Out[38]: dtype('int64')

In [39]: float_arr = arr.astype(np.float64)

In [40]: float_arr.dtype
Out[40]: dtype('float64')
</code></pre> <p>In this example, integers were cast to floating point. If I cast some floating-point numbers to be of integer dtype, the decimal part will be truncated:</p> <pre><code class="language-Python">In [41]: arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])

In [42]: arr
Out[42]: array([ 3.7, -1.2, -2.6, 0.5, 12.9, 10.1])

In [43]: arr.astype(np.int32)
Out[43]: array([ 3, -1, -2, 0, 12, 10], dtype=int32)

In [44]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)

In [45]: numeric_strings.astype(float)
Out[45]: array([ 1.25, -9.6 , 42. ])
</code></pre> <h3 id="warning">Warning</h3> <p>It’s important to be cautious when using the <code class="language-plaintext highlighter-rouge">numpy.string_ type</code>, as string data in NumPy is fixed size and may truncate input without warning. pandas has more intuitive out-of-the-box behavior on non-numeric data.</p> <p>If casting were to fail for some reason, <code class="language-plaintext highlighter-rouge">ValueError</code> will be raised.</p> <h2 id="arithmetic-with-numpy-arrays">Arithmetic with NumPy Arrays</h2> <p>Arrays are important because they enable you to express batch operations on data without writing any <code class="language-plaintext highlighter-rouge">for</code> loops. <code class="language-plaintext highlighter-rouge">NumPy</code> users call this <em>vectorization.</em> Any arithmetic operations between equal-size arrays applies the operation element-wise:</p> <pre><code class="language-Python">In [51]: arr = np.array([[1., 2., 3.],[4., 5., 6.]])

In [52]: arr
Out[52]:
array([[ 1., 2., 3.],
       [ 4., 5., 6.]])

In [53]: arr*arr
Out[53]:
array([[  1.,  4.,  9.],
       [ 16., 25., 36.]])

In [54]: arr - arr
Out[54]:
array([[ 0., 0., 0.],
       [ 0., 0., 0.]])

</code></pre> <p>Arithmetic operations with scalars propagate the scalar argument to each element in the array. Comparison between array of the same size yield boolean arrays</p> <pre><code class="language-Python">In [55]: 1 / arr
Out[55]:
array([[ 1. , 0.5 , 0.3333],
[ 0.25 , 0.2 , 0.1667]])

In [56]: arr ** 0.5
Out[56]:
array([[ 1. , 1.4142, 1.7321],
[ 2. , 2.2361, 2.4495]])

In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

In [58]: arr2
Out[58]:
array([[ 0., 4., 1.],
[ 7., 2., 12.]])

In [59]: arr2 &gt; arr
Out[59]:
array([[False, True, False],
[ True, False, True]], dtype=bool)

</code></pre> <p>Operations between differently sized arrays is called <strong>broadcasting</strong>.</p> <h2 id="basic-indexing-and-slicing">Basic indexing and slicing</h2> <p>NumPy array indexing is a rich topic, as there are many ways you may want to select a subset of your data or individual elements.</p> <pre><code class="language-Python">In [60]: arr = np.arange(10)

In [61]: arr
Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [62]: arr[5]
Out[62]: 5

In [63]: arr[5:8]
Out[63]: array([5, 6, 7])

In [64]: arr[5:8] = 12

In [65]: arr
Out[65]: array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9])

</code></pre> <p>If you assign a scalar value to a slice, as in <code class="language-plaintext highlighter-rouge">arr[5:8] = 12</code> the value is propagated (or <em>broadcasted</em> henceforth) to the entire selection.</p> <p>Array slices are <em>views</em> on the original array, which means</p> <ol> <li>Data is not copied</li> <li>Any change to the view (like assignment) is reflected in the original array</li> </ol> <blockquote> <p>If you want copy of a slice of an array, then you need to explicitly copy the array, like <code class="language-plaintext highlighter-rouge">arr[5:8].copy()</code></p> </blockquote> <p>An example(to indicate that slices are indeed views on the original array)</p> <pre><code class="language-Python">In [66]: arr_slice = arr[5:8]

In [67]: arr_slice
Out[67]: array([12, 12, 12])

In [68]: arr_slice[1] = 12345

In [69]: arr
Out[69]: array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8,
9])

In [70]: arr_slice[:] = 64

In [71]: arr
Out[71]: array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])

</code></pre> <p>In higher dimensional arrays we have many more option, like in two dimensional arrays the elements at each index are no longer scalar but one dimensional arrays, so individual elements of these arrays can be accessed via double indexing.</p> <p>Individual elements in two dimensional arrays can be accessed recursively but that’s a bit of work. So, a better option is to pass tuple of two elements like below</p> <pre><code class="language-Python">In [74]: arr2d[0][2]
Out[74]: 3

In [75]: arr2d[0, 2]
Out[75]: 3
</code></pre> <p>In multidimensional arrays, if you omit later indices, the returned object will be a lower dimensional ndarray consisting of all the data along the higher dimensions.</p> <h2 id="indexing-with-slices">Indexing with slices</h2> <p>Like one dimensional objects such as python lists, ndarrays can be sliced with the familiar syntax:</p> <pre><code class="language-Python">In [88]: arr
Out[88]: array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])

In [89]: arr[1:6]
Out[89]: array([ 1, 2, 3, 4, 64])
</code></pre> <p>You can also pass multiple indices like in case you do with python lists.</p> <h2 id="boolean-indexing">Boolean Indexing</h2> <p>Let’s consider an example where we have some data in an array and an array of names with duplicates. I’m going to use here the <code class="language-plaintext highlighter-rouge">randn</code> function in <code class="language-plaintext highlighter-rouge">numpy.random</code> to generate some random normally distributed data:</p> <pre><code class="language-Python">In [98]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

In [99]: data = np.random.randn(7, 4)

In [100]: names
Out[100]:
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	dtype='&lt;U4')

In [101]: data
Out[101]:
array([[ 0.0929, 0.2817, 0.769 , 1.2464],
       [ 1.0072, -1.2962, 0.275 , 0.2289],
       [ 1.3529, 0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397, 0.477 ],
       [ 3.2489, -1.0212, -0.5771, 0.1241],
       [ 0.3026, 0.5238, 0.0009, 1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre> <p>The boolean condition <code class="language-plaintext highlighter-rouge">names == 'Bob'</code> returns a boolean array, whose <em>i</em>th index element is <code class="language-plaintext highlighter-rouge">names[i] == 'Bob'</code></p> <p>This array can be further passed to <code class="language-plaintext highlighter-rouge">data</code> , which gives array containing elements in whose index the boolean array is true, which means that the length of both <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">names</code> must be same.</p> <blockquote> <p>Boolean selection will not fail if the boolean array is not the correct length, so it must be used with care.</p> </blockquote> <p>You can further slice the array <code class="language-plaintext highlighter-rouge">data[names == 'Bob']</code> the way you want and it will give suitable results. To be clear you can treat it like any other ndarray.</p> <p>The above idea can be further extended to the definition of <code class="language-plaintext highlighter-rouge">arr[bool]</code> where <code class="language-plaintext highlighter-rouge">arr[bool][i] = True</code> if <code class="language-plaintext highlighter-rouge">bool[i]</code> is and <code class="language-plaintext highlighter-rouge">arr[bool][i] = False</code> if <code class="language-plaintext highlighter-rouge">bool[i]</code> is <code class="language-plaintext highlighter-rouge">False</code>.</p> <blockquote> <table> <tbody> <tr> <td>Despite this extension, it is more safe to use &amp;(and) and</td> <td>(or) instead of and and or, this is because boolean arrays only work with these symbols</td> </tr> </tbody> </table> </blockquote> <p>Setting values with boolean arrays is also, easy as boolean arrays are in essence subarray of an array, a single assignment would change the value of all the elements for whose index the boolean condition is true.</p> <blockquote> <p>Here boolean array refers to something like <code class="language-plaintext highlighter-rouge">arr[bool]</code></p> </blockquote> <h2 id="fancy-indexing">Fancy Indexing</h2> <p><em>Fancy Indexing</em> is a term adopted by NumPy to describe indexing using integer arrays. Suppose we had an 8 x 4 array:</p> <pre><code class="language-Python">In [117]: arr = np.empty((8, 4))
In [118]: for i in range(8):
	    :    arr[i] = i
In [119]: arr
Out[119]:
array([[ 0., 0., 0., 0.],
       [ 1., 1., 1., 1.],
       [ 2., 2., 2., 2.],
       [ 3., 3., 3., 3.],
       [ 4., 4., 4., 4.],
       [ 5., 5., 5., 5.],
       [ 6., 6., 6., 6.],
       [ 7., 7., 7., 7.]])
</code></pre> <p>To select out a subset of rows you can simply pass a list or ndarray containing those specific indexes.</p> <pre><code class="language-Python">In [120]: arr[[4, 3, 0, 6]]
Out[120]:
array([[ 4., 4., 4., 4.],
       [ 3., 3., 3., 3.],
       [ 0., 0., 0., 0.],
       [ 6., 6., 6., 6.]])
</code></pre> <pre><code class="language-Python">In [122]: arr = np.arange(32).reshape((8, 4))

In [123]: arr
Out[123]:
array([[ 0, 1, 2, 3],
       [ 4, 5, 6, 7],
       [ 8, 9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
In [124]: arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Out[124]: array([ 4, 23, 29, 10])
</code></pre> <p>Here <code class="language-plaintext highlighter-rouge">np.arange</code> creates an array of integers from 1 to 32 in ascending order, and <code class="language-plaintext highlighter-rouge">.reshape</code> method just creates an array which as no. of elements equal to the first argument and each element is an array having cardinal number equal to the second argument.</p> <p>Fancy indexing unlike slicing always copies the data into a new array meaning any change in the resultant fancy indexed array does not change the parent array.</p> <h2 id="transposing-array-and-swapping-axes">Transposing array and swapping Axes</h2> <p>Transposing is a special form of reshaping that similarly returns a view on the underlying data without copying anything. Arrays have the <code class="language-plaintext highlighter-rouge">transpose</code> method and also the special T attribute:</p> <pre><code class="language-Python">In [126]: arr = np.arange(15).reshape((3, 5))
In [127]: arr
Out[127]:
array([[ 0, 1, 2, 3, 4],
       [ 5, 6, 7, 8, 9],
       [10, 11, 12, 13, 14]])
In [128]: arr.T
Out[128]:
array([[ 0, 5, 10],
       [ 1, 6, 11],
       [ 2, 7, 12],
       [ 3, 8, 13],
       [ 4, 9, 14]])
</code></pre> <p>When doing matrix computation, we can compute the matrix inner product using <code class="language-plaintext highlighter-rouge">np.dot(matrix1,matrix2)</code> where <code class="language-plaintext highlighter-rouge">matrix1</code> and <code class="language-plaintext highlighter-rouge">matrix2</code> are numpy arrays.</p> <p>For higher dimensional arrays, <code class="language-plaintext highlighter-rouge">transpose</code> will accept a tuple of axis numbers to permute the axes (for extra mind bending):</p> <pre><code class="language-Python">In [132]: arr = np.arange(16).reshape((2,2,4))

In [133]: arr
Out[133]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],
       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [134]: arr.transpose((1, 0, 2))
Out[134]:
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],
       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
</code></pre> <blockquote> <p>This is how <code class="language-plaintext highlighter-rouge">transpose</code> function or method works: Suppose the input array is $n$ dimensional and the input tuple of <code class="language-plaintext highlighter-rouge">transpose</code> method is essentially a permutation of numbers from 0 to $(n-1)$. Let the input permutation be $(a_1, a_2 , a_3 , …, a_n)$ and the initial array be <code class="language-plaintext highlighter-rouge">arr</code> and new array be <code class="language-plaintext highlighter-rouge">narr</code>, then what we are doing is essentially the assignments,</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="n">narr</span> <span class="p">[</span><span class="n">m1</span><span class="p">]</span> <span class="p">[</span><span class="n">m2</span><span class="p">]</span> <span class="p">[</span><span class="n">m3</span><span class="p">]</span> <span class="p">[</span><span class="n">m4</span><span class="p">]</span> <span class="p">....</span> <span class="p">[</span><span class="n">mn</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span> <span class="p">[</span><span class="n">ma1</span><span class="p">]</span>  <span class="p">[</span><span class="n">ma2</span><span class="p">]</span>  <span class="p">[</span><span class="n">ma3</span><span class="p">]</span> <span class="p">....</span> <span class="p">[</span><span class="n">man</span><span class="p">]</span>
</code></pre></div> </div> </blockquote> <p>Similarly there is <code class="language-plaintext highlighter-rouge">swapaxes</code> method in python, this method works by returning a view on data without making a copy.</p> <p>This method accepts two values. the axes that need to be swapped, it is essentially a transposition, which means it is equivalent to applying <code class="language-plaintext highlighter-rouge">transpose</code> method to the permutation generated by this transposition.</p> <h2 id="universal-functions-fast-element-wise-array-functions">Universal Functions: Fast Element-Wise Array Functions</h2> <p>A universal function or <em>ufunc</em>, is a function that performs element-wise operations on data in ndarrays. They can be thought of as fast vectorized wrappers for simple functions that take one or more scalar values and produce one or more scalar results.</p> <p>Many ufuncs are simple element- wise transformations, like <code class="language-plaintext highlighter-rouge">sqrt</code> or <code class="language-plaintext highlighter-rouge">exp</code>.</p> <p><code class="language-plaintext highlighter-rouge">np.sqrt(array)</code> just takes the array as input and generates(a copy) an array with each element square rooted.</p> <p>Such ufuncs which take only element as input are <em>unary</em> ufuncs and others such as <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">maximum</code>, take two arrays (thus, <em>binary</em> ufuncs) and return a single array as result.</p> <p>Both the above methods generate an array, thus its obvious to accurately guess what they do.</p> <p><strong>Not common,</strong> but ufunc can return multiple arrays. <code class="language-plaintext highlighter-rouge">modf</code> is one example, a vectorized version of built-in Python <code class="language-plaintext highlighter-rouge">divmod</code>; it returns the fractional and integral parts of a floating-point array:</p> <p>It returns the tuple <code class="language-plaintext highlighter-rouge">(remainder, whole part)</code></p> <p>Ufuncs also accept an optional <code class="language-plaintext highlighter-rouge">out</code> argument that allows them to operate in place on arrays.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">out</code> is the second argument, applying the ufunc with this argument, just assigns the resulting array to the variable in <code class="language-plaintext highlighter-rouge">out</code></p> </blockquote>]]></content><author><name></name></author><category term="notes"/><category term="notes"/><summary type="html"><![CDATA[notes about numpy arrays]]></summary></entry></feed>